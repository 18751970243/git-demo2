1、如何实现线程池？
所谓的线程池就是事先创建好指定数目的线程，当同步队列为空的时候，线程全部处于等待状态，一旦同步队列被添加了事务，线程池就从同步队列中取事务并进行处理，处理完成之后又会重新获取同步队列中的事务。如果同步队列为空，就再次处于等待状态；如果没有空闲线程但是有新任务产生就放在同步队列中，等待线程执行完当前事务之后才能执行。
线程池的优点：
①降低资源的消耗：通过重复利用线程可以减少因频繁创建和销毁线程所带来的消耗。
②提高响应速度：当执行同步队列中的事务的时候，省去了创建线程的时间。
③提高线程的可管理性：线程是稀缺资源，如果无限制的创建线程，不仅会消耗系统的资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。


2、有哪些线程安全的问题？
线程安全问题就是在多线程环境中 , 并且存在数据共享 （即多个线程操作同一个数据），线程安全可以简单理解为一个方法或者一个实例可以在多线程环境中使用而不会出现问题。

3、hashmap高并发下的问题
HashMap没有对多线程的场景下做任何的处理，不用说别的，就两个线程同时put，然后冲突了，两者需要操作一个链表/红黑树，这肯定就会有错误发生，所以HashMap是线程不安全的。


4、java 7、8的区别
java7中hashmap的实现为数组+链表的形式，高并发多线程下，需要resize,rehash，会形成循环链表，死循环
java8的改进
添加了红黑树，当链表长度大于8时，会将链表转为红黑树。
扩容后，新数组中的链表顺序依然与旧数组中的链表顺序保持一致。具体jdk8是用 head 和 tail 来保证链表的顺序和之前一样，这样就不会产生循环引用。也就没有死循环了。
虽然修复了死循环的bug，但是hashmap 还是非线程安全类，仍然会产生数据丢失等问题。


5、HashMap、Hashtable、ConccurentHashMap 三者的区别
HashMap线程不安全，数组+链表+红黑树
Hashtable线程安全，锁住整个对象，数组+链表
ConccurentHashMap 线程安全，CAS+同步锁、数组+链表+红黑树
HashMap的key，value均可为null，其他两个不行。

6、对并发包的了解 
（1）ConcurrentHashMap：
解决hashMap 并发线程安全问题，使用node+cas+syntronized
（2）CopyOnWriteArrayList
解决ArrayList 并发线程安全问题，增删改上锁、读不上锁，读多写少且脏数据影响不大的并发情况下，选择CopyOnWriteArrayList
（3）CopyOnWriteArraySet
跟CopyOnWriteArrayList 差不多，主要是不能重复
（4）ArrayBlockingQueue
基于数组、先进先出、线程安全，可实现指定时间的阻塞读写，并且容量可以限制
（5）LinkedBlockingQueue
基于链表实现，读写各用一把锁，在高并发读写操作都多的情况下，性能优于ArrayBlockingQueue


7、遇到过线程安全的问题吗，线程安全的本质 是什么 ，线程对内存的操作有关系，jvm的内存模型大概是什么样子的，JVM在读一个内存数据的时候，过程是什么样子 ，这个过程能解释线程安全的问题

8、jvm内存模型

9、spring boot 如何提供api接口
restController，requestMapping，postMapping

10、spring boot 线程安全吗？如果改成多例的，还会出现线程安全问题吗
单例的，线程不安全
改成多例的，不会出现线程安全问题，因为每次都会new一个新的对象，这样开销会比较大，单例的可以复用

11、redis用的什么架构模式
cluster具体怎么实现
三个主之间什么关系
什么数据放在哪个节点，如何计算？

（1）cluster 一主多从，从不提供服务，只提供备份，主节点挂掉，从节点上。
（2）通过hash算法，把数据分摊到各个节点
（3）cluster扩展性较强，压力分摊，

12、redis除了cluster,还有其他方式吗？
哨兵模式，基于主从模式，主节点，从节点，不好在线扩容。也没有实现访问压力分摊

13、redis的热key，大value的问题

高访问量的 Key，也就是热 key，根据过去的维护经验一个 key 访问的 QPS 超过 1000 就要高度关注了，比如热门商品，热门话题等。
大 Value，有些 key 访问 QPS 虽然不高，但是由于 value 很大，造成网卡负载较大，网卡流量被打满，单台机器可能出现千兆 / 秒，IO 故障。

如何识别到热点key呢？
1、凭经验判断哪些是热Key；
2、客户端统计上报；
3、服务代理层上报

如何解决热key问题？（多key，本地缓存）
1、Redis集群扩容：增加分片副本，均衡读流量；
2、将热key分散到不同的服务器中；
3、使用二级缓存，即JVM本地缓存,减少Redis的读请求。
4、热点key限流

怎么识别大value
大：string 类型 value > 10K，set、list、hash、zset 等集合数据类型中的元素个数 > 1000。
超大： string 类型 value > 100K，set、list、hash、zset 等集合数据类型中的元素个数 > 10000。

解决方案：拆分多个key-value存储


14、MQ中的消息顺序性问题
拆分多个queue，每个queue一个consumer，就是多一些queue而已，确实是麻烦点；这样也会造成吞吐量下降，可以在消费者内部采用多线程的方式取消费。

15、MQ为什么会出现消息重复问题，如何解决消息重复问题
前端重复点击产生消息或者是重试机制导致的

接口幂等设计

16、MQ如何解决消息丢失问题
ack

17、获得锁之后一直不释放，怎么解决
增加过期时间

如果时间过了，还没有释放，系统自动释放，其他线程又更改了数据，（增加看门狗，延长过期时间）


18、java的类加载过程
编译、运行
编译，即把我们写好的java文件，通过javac命令编译成字节码，也就是我们常说的.class文件。
运行，则是把编译声称的.class文件交给Java虚拟机(JVM)执行。

19、java虚拟机的基本结构

20、谈一下Java堆的垃圾回收机制

21、java8的新特性
（1）hashmap 增加了红黑树
（2）增加了lambda表达式
（3）concurrentHashMap有原来的分段锁协议提升为CAS算法（什么是cas算法）
（4）新增了Stream流的支持， 例如FileInputStream，FileOutPutStream。字节流

22、redis持久化
AOF：先把命令追加到操作日志的尾部，保存所有的历史操作
RDB：指定的时间间隔内保存数据快照

23、项目中用到了哪些集合类
List、set、Map

Set下有HashSet，LinkedHashSet，TreeSet
List下有ArrayList，Vector，LinkedList
Map下有Hashtable，LinkedHashMap，HashMap，TreeMap

List 列表，有序，可重复
Queue 队列，有序，可重复
Set 集合，不可重复
Map 映射，无序，键唯一，值不唯一每种集合类型下都包含多个具体的实现类

如果需要快速随机访问元素，应该使用ArrayList。需要键值对形式的数据时，应该使用HashMap

24、说说 volatile 底层、synchronized 底层、锁升级的过程

volatile变量，用来确保将变量的更新操作通知到其他线程
从java内存模型解释，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：Java内存模型）来完成。

synchronized和volatile的区别：
一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：
1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是
    立即可见的。
2）禁止进行指令重排序。
   volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；
   synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。

无锁->偏向锁->轻量级锁->重量级锁的升级过程

25、对 CAS 的理解，CAS 带来的问题，如何解决这些问题？
CAS是compare and swap的缩写，即我们所说的比较交换。

cas是一种基于锁的操作，而且是乐观锁。在java中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加version来获取数据，性能较悲观锁有很大的提高。

CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。


26、怎么理解 Java 中和 MySQL 中的乐观锁、悲观锁？
java 中的乐观锁：cas，悲观锁：synchronied

数据库：
乐观锁
总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。

版本号机制
一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若version值变动了，则更新失败。

CAS
CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。

悲观锁
总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

表锁：（1）增删改查未匹配到索引（2）修改表结构
行锁：增删改查 匹配到了索引，就会使用行锁，匹配不到就会使用表锁
全局锁：全局锁的典型场景应用场景是全库逻辑备份




27、如何理解 Spring 中的 AOP 和 IOC，读过 Spring 源码没有？

28、有没有排查过线上 OOM 的问题，如何排查，谈下对 GC 的了解，何为垃圾，有哪些 GC 算法，有哪些垃圾回收器，你是如何调优的。

何为垃圾：如果对象实体没有引用指向的话，存储该实体的内存便成为垃圾

复制算法：miner GC 工作方式 （eden、from、to），优点：不会导致内存空间的碎片化  缺点：内存消耗比较大
标记清除算法：full GC （老年代的工作方式） 这种算法虽然不需要多余的内存空间 “周转” 对象，但是会导致内存碎片化。于是便引出了标记压缩算法
标记压缩算法：在标记清除后加了一个 “压缩” 操作，将分散的数据压缩到一块连续的内存空间。就是慢，但慢工出细活

新生代收集器：Serial、ParNew、Parallel Scavenge；
老年代收集器：Serial Old、Parallel Old、CMS；
整堆收集器：G1；
参考：https://www.cnblogs.com/cxxjohnson/p/8625713.html

jvm如何进行调优的：
如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化，如果GC时间超过1-3秒，或者频繁GC，则必须优化。
设置内存大了，会增加gc时间，如果设置小了，会频繁GC，所以要找到一个合适的值


29、JVM 自带的工具有哪些，都有什么功能？
内存溢出：Jmap导出内存溢出文件，MAT进行分析
CPU过高：Top列出内存过高的进程，Jstack导出进程状态，进行分析

jinfo
jstat -gcutil pid可以查看内存回收日志


30、MySQL 索引底层实现为什么不用 B-Tree，红黑树，为什么不用 hash

首先说红黑树为什么不行：
1.红黑树必须存在内存里的，数据库表太大了，存不进去。
2.即使你找到了把红黑树存进硬盘的方法，红黑树查找一个节点最多要查logN层，每一层都是一个内存页（虽然你只是想找一个节点，但硬盘必须一次读一个页。。），那么一共logN次IO，伤不起阿！
 
所以我们必须考虑减少树的层数来减少IO次数从而加快查询、修改数据库效率，b和b+树都符合这样的性质，它们每个节点的孩子都很多（几十~几千），所以整个树的高度可以压的很低。
比如100000000数据，每个节点有1000个孩子，那么log 1000(100000000)<3，3层就足够存了！
 
先讲下b树和b+树的区别：
b树的所有节点都是数据节点，但b+树只有叶子节点是数据节点，非叶子（内部）节点只起导向作用，不存储实际数据。
b+树的所有数据节点都在最下层（叶子节点层），相邻节点有链表相连。
注意磁盘读数据读一个字节和读10个字节和读一页时间相差不大的（因为磁盘查找时间大多数都花在寻道上，旋转基本不费时）
再说b树为什么不如b+树：
1.b树的内部节点都是存储实际数据的，比如一个节点是一个页4096字节，其中每条数据128字节，那么一个节点只能存32个数据项，那么对应的孩子节点数最多为33个，这显然不够用。而b+树内部节点只作为导向作用，只存一个整数就可以，4096/4=1024个数据项。这样b+树的每个节点的孩子数更多，整个树的高度就更低，大大增加查询效率。
2.b+树的叶子节点有链表相连，适合范围查询，因为相邻页直接读取就好了。但b树做不到这一点。
就简单说这些。

hash：无序，全表扫描，效率低

31、MySQL 默认的事务隔离级别，MVCC、RR 怎么实现的？
隔离级别是可重复读，整个事务看到的事务和事务开启时看到的数据是一致的，开启看到的数据是1，所以V1、V2的值都是1,事务A提交之后，获取到修改后的数据，所以V3的值是2。
隔离级别的主要是多版本并发控制MVCC,MVCC是通过保存数据在某个时间点的快照来实现的。
InnoDB实现的MVCC，是通过在每行记录后面保存两个隐藏列来实现，一个是保存行的创建时间，另一个是保存行的过期时间。当然存储的不是时间，而是系统版本号。每开启一个新的事务，系统版本号先自动递增，该系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号做比较。

32、MySQL 间隙锁/死锁，写一段会造成死锁的 SQL 语句，死锁发生了如何解决，如何解决死锁。
对同一个资源发生争抢，顺序性不同，导致死锁
(1)争抢资源时，先锁住， select   for update
(2)select for update 锁住了，这时 insert 也会发生死锁，解决：insert into t3(xx,xx) on duplicate key update `xx`='XX';


33、项目中如何保证接口的幂等操作，用什么方法。
（1）代码逻辑控制，比如支付的时候，通过订单号判断是否支付过
（2）防止重复提交， token判断，大致思路就是当发生页面跳转时生成token并存入像redis等的缓存，调用接口时带着token访问，接口完成时删除token，这种可以起到避免重复调用的功能。
（3）高并发下可以用分布式锁
（4）系统缓存所有请求与处理结果，检测到重复请求之后，自动返回之前的处理结果 

34、Hystrix 功能和在项目中怎么使用的？Hystrix 实现原理？
高并发处理方式：限流、熔断、降级
histrix 解决 熔断、降级

Netflix的 Hystrix 是一个帮助解决分布式系统交互时超时处理和容错的类库, 它同样拥有保护系统的能力.
Hystrix的设计原则包括:资源隔离、熔断器、命令模式。
线程池隔离：

熔断器：
当熔断器开关打开时, 请求被禁止通过.

命令模式：
Hystrix使用命令模式(继承HystrixCommand类或者是HystrixObservableCommand类)来包裹具体的服务调用逻辑(run方法), 并在命令模式中添加了服务调用失败后的降级逻辑(getFallback).
同时我们在Command的构造方法中可以定义当前服务线程池和熔断器的相关参数. 

35、Redis 底层数据结构原理


36、Redis 如何实现分布式锁？
通过redis的单线程、原子性

37、说一个你了解最多的中间件框架

38、如何理解分布式事务，为什么会出现这个问题，如何去解决，了解哪些分布式事务中间件？
两类模式：
tcc：try、confirm、cancel，依赖每个节点的本地事务，每个事务必须准确，只要一个出错，全部cancel，rollback
常见的有阿里的seata
xa：资源管理器往往由数据库实现，如Oracle、DB2、MySQL，这些商业数据库都实现了XA 接口，而事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。

39、讲一讲项目中的难点、挑战，是如何解决的，项目这一块会问的特别细。

40、设计模式
单例模式、代理模式、适配器模式、工厂模式

41、spring mvc的原理

42、mysql和oracle的区别
（1）自增字段不同（2）分页查询（3）函数 (4)隔离级别（mysql是可重复读、oracle读提交）
读提交：事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。可能出现 不可重复读 
可重复读：整个事务看到的事务和事务开启时看到的数据是一致的，开启看到的数据是1，所以V1、V2的值都是1,事务A提交之后，获取到修改后的数据，所以V3的值是2。


43、索引怎么用，怎么去优化索引

44、一般怎么去查sql变慢

45、webservice一般用的什么，soap还是其他，用的什么框架
soap协议 是webservice的协议

46、java多态的理解


47、HashMap 的数据结构是什么？如何实现的。和 HashTable、ConcurrentHashMap 的区别
8个以下为链，8个以上转成了红黑树。hashMap 并发会出现线程安题。
hashTable 通过syntronized 进行修饰，保证线程安全，但效率不高
ConcurrentHashMap 保证线程安全，通过node+cas+syntronized 实现

48、什么情况会出现 Full GC，什么情况会出现 young GC
Full GC ：老年代空间不足、元空间空间不足
Young GC : 
1、Eden区域满
2、新创建的对象大小 > Eden所剩空间

49、讲讲 JVM 加载字节码文件的过程
类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个这个类的java.lang.Class对象，用来封装类在方法区类的对象。看下面2图
方法区包含所有的class信息和static变量
堆区：描述类的Class对象

50、Spring 的 IOC 容器初始化流程
Spring IOC容器初始化过程总得说起来也简单，基本是整个Spring启动的过程。大体流程：
Spring启动 -> 加载配置文件 -> 将配置文件转化成Resource -> 从Resource中解析转换成BeanDefinition -> 主动或则被动触发Bean的初始化过程 -> 应用程序中使用Bean -> 销毁Bean -> 容器关闭。

51、对 CAS 的理解，CAS 带来的问题，如何解决这些问题
CAS：Compare and Swap，即比较再交换。
jdk5增加了并发包java.util.concurrent.*,其下面的类使用CAS算法实现了区别于synchronouse同步锁的一种乐观锁。JDK 5之前Java语言是靠synchronized关键字保证同步的，这是一种独占锁，也是是悲观锁。
对CAS的理解，CAS是一种无锁算法，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。
举例：t1、t2线程同时访问同一个变量，变量值56，他们会同时拷贝一份到自己的工作内存空间，所以t1、t2线程的预期值都是56
t1、t2竞争，t1成功，t2失败(t2稍后再试)，t1更改变量为57，然后写入到堆内存中，这时候t2再去修改，堆内存变成了57，跟本地工作空间的预期值56不一致，就操作失败了。


52、为什么说CAS是乐观锁？
乐观锁，严格来说并不是锁，通过原子性来保证数据的同步，比如说数据库的乐观锁，通过版本控制来实现，所以CAS不会保证线程同步。乐观的认为在数据更新期间没有其他线程影响。

53、使用乐观锁还是悲观锁
我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的吞吐量。但如果是多写的情况，一般会经常发生冲突，这就会导致CAS算法会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。

54、CAS优缺点
优点
非阻塞的轻量级的乐观锁，通过CPU指令实现，在资源竞争不激烈的情况下性能高，相比synchronized重量锁，synchronized会进行比较复杂的加锁、解锁和唤醒操作。
缺点
（1）ABA问题： 线程C、D；线程D将A修改为B后又修改为A，此时C线程以为A没有改变过，java的原子类AtomicStampedReference，通过控制变量值的版本号来保证CAS的正确性。具体解决思路就是在变量前追加上版本号，每次变量更新的时候把版本号加一，那么A - B - A就会变成1A - 2B - 3A。
（2）自旋时间过长，消耗CPU资源，如果资源竞争激烈，多线程自旋长时间消耗资源

55、说说你对乐观锁和悲观锁的理解
syntronized  、 cas 

56、你能否写一个 Rpc 框架，什么时候序列化/反序列化
动态代理（用到了反射）、序列化、鉴权、传输（socket、netty）

57、如何存放数据到 Redis 集群，介绍一下这个过程

58、分库分表使用什么算法拆分，简述一下一致性 Hash 算法原理
取模、hash、时间范围

59、MySQL 事务隔离级别和 MVCC，事务的底层实现原理

60、JVM内存结构
堆区：内存的分配回收（对象、数组），young区（s0/s1/eden）、old区，通过-Xmx32M -Xms32M设置大小
非堆区：方法区、程序计数器、本地方法栈、虚拟机栈
其中方法区，又叫metaspace,存储的是类的信息，静态变量，通过-XX:MetaspaceSize=32M来设置大小

61、生产环境如何监测内存溢出
java的内存溢出，是new了一个对象之后，一直得不到释放
（1）用jmap 查看java进程的堆信息
jmap -heap 4717
（2）使用Eclipse MAT 分析JVM内存溢出文件（用jmap -dump导出）、或者JVisualVM

62、排查cpu过高
Top列出内存过高的进程，Jstack导出进程状态，进行分析，找出BLOCKED，WAITING的线程。

63、线上问题如何调测
btrace，可以动态地跟踪java运行程序，将跟踪字节码注入到运行类中，对运行代码侵入较小，对性能上的影响可以忽略不计。

64、gc的过程
eden、from、to、old
在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。
老年区满会触发full gc，FULL GC会导致stop-the-world，频繁的FULL GC会影响系统的可用性。

1.yongGC 执行时间不超过50ms 执行频率不小于10s每次
2.FullGC 执行时间不超过1s，执行频率不低于10分钟
有人会说full GC的执行间隔越长越好，因为会stop the world，但是意味着metaspace设置的过大，在full gc的时候，可能会越慢，所以需要找一个平衡值。

65、垃圾回收算法
标记清除、复制、标记整理
young区标记清除（大部分的对象的生命周期很短，朝生夕死，转眼就被回收了，存活的对象少，所以效率高）
old区复制（Old区生命周期比较长，如果采用复制的方式，转来转去，并没有太大的变化，效率低）

66、常见的监控工具
关于性能监控这块的工具有linux的top指令及查看进程相关指令，jinfo，jps，jstat，jmap，jstack，jconsole。
先简单介绍一下
top指令：查看当前所有进程的使用情况，CPU占有率，内存使用情况，服务器负载状态等参数。除此之外它还是个交互命令，使用可参考完全解读top。
jps：与linux上的ps类似，用于查看有权访问的虚拟机的进程，可以查看本地运行着几个java程序，并显示他们的进程号。当未指定hostid时，默认查看本机jvm进程。(jps -l)
jinfo：可以输出并修改运行时的java 进程的一些参数。（jinfo -flag MaxHeapSize pid）
jstat：可以用来监视jvm内存内的各种堆和非堆的大小及其内存使用量。(jstat -class pid，jstat -compile pid)
jstack：堆栈跟踪工具，一般用于查看某个进程包含线程的情况。监测CPU过高的问题 （jstack pid）
jmap：打印出某个java进程（使用pid）内存内的所有对象的情况。一般用于查看内存占用情况。(jmap -heap pid)
jconsole：一个java GUI监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器的jvm进程。

观察gc过程：
jstat -gcutil 49 1000，表示查看进程号是49的进程的gc情况，每隔1000ms打印一次。



67、maven的命令
mvn clean package：删除目标文件夹、编译代码并打包
mvn clean install：删除目标文件夹、编译代码并打包、将打好的包放置到本地仓库中

68、mybatis 与 hibernate的区别
mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。
Hibernate对象/关系映射能力强

69、mybatis的一级缓存、二级缓存
一级缓存作用域是sqlsession,同一个sqlsession 执行同一个sql，第一次执行会把数据扔到缓存里，第二次直接从缓存中捞取
二级缓存作用域是多个sqlsession，执行相同的sql语句，会扔到内存里。
mybatis默认开启一级缓存。

70、spring 中的设计模式
工厂模式、代理模式（AOP）、单例模式、适配器模式（AOP）、装饰器模式（连接多个数据库，动态切换）、模板模式（jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类）

71、java 内存模型
java的内存模型用于定义变量的访问规则，变量都是共享的变量（实例字段、静态字段和构成数组对象）
工作内存：主内存的副本+私有元素（存储于虚拟机栈中）
主内存：公共的元素，包括实例字段、静态字段、构成对象的元素（存储于堆中）
Java 内存模型中规定了所有的变量都存储在主内存中，每个线程还有自己的工作内存（类比缓存理解），线程的工作内存中保存了该线程使用到主内存中的变量拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递（通信）均需要在主内存来完成


72、spring mvc 单例模式下  会出现线程安全问题，怎么从java内存线程模型进行解释
单例模式下，变量是共享的，当多线程调用的时候，对同一共享数据进行读写，会出现线程安全问题
共享的数据是放在主内存中，每个线程都有一个本地内存，本地内存存储的是主内存的副本，线程访问变量的时候，从本地
内存中读写，然后再刷回到主内存中，这时候如果另一个线程也在对内存读写，就会存在顺序问题，导致线程安全问题。
我们在使用spring mvc 的contrller 单例模式时，应避免在controller中定义实例变量。
SpringMVC 或 SpringBoot 默认是单例模式（Singleton）

共享资源访问控制标准：原子性、可见性、有序性（并发编程的三要素）
volatile：无法保证原子性，保证了可见性
a++存在线程安全问题，不具备原子性，可通过syncronized 保证原子性
通过volatile/syncronized 保证有序性

73、hystrix 线程池隔离、信号量隔离
线程池隔离：将不同的业务隔离开来，互不影响，自己的资源耗尽就报错
信号量隔离：设置对应的信号，如果用完，就报错
以上报错，走降级方法

线程池隔离适合并发量大，耗时长的场景，这样保证其他的服务有充足的线程来用
信号量隔离适合并发量大，耗时短的场景，这样不会占用太长时间，也减少了线程开销，常见的zuul就是采用的信号量

74、说说 Redis 常用几种类型，各自底层是怎么实现的，项目中如何使用。


75、数据库和缓存双写一致性问题
延迟双删

76、设计一个发号器，考虑集群和高并发的情况，要求发号器生成的 id 是递增趋
snowflake（机器码+时间+自增id）

77、项目中系统监控怎么做的？（可以了解下美团开源的 CAT 系统，还是很出色的）
Zikpin，与Spring Cloud Sleuth结合的比较好

78、什么是IOC 控制反转
正转：内部逻辑，new 对象，调用
反转：由容器创建和注入依赖对象
 

linux相关命令
java继承、多态
网站安全

